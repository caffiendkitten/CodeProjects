<div class="help">
    <h1>Hacking Cheat Sheet</h1>
    <hr>

    <h3>Reconnaissance</h3>
    <h4><em>Map Out the Attack Surface</em> Parts of the site may be hidden. These techniques will help you find them.</h4>

    <h5>Check robots.txt</h5>
    <p>The robots.txt file, found in a site's web root, tells well-behaved web crawlers what parts of the site to ignore. You're not a well-behaved web crawler, so you can look at those pages. You may find pages the rest of the site doesn't link to.</p>

    <h5>Try some common URLs</h5>
    <p>By guessing common page and directory names, you might be able to discover even more content. A tool like dirbuster can help (but it's probably overkill here).</p>

    <h5>Look for HTML comments &amp; hidden elements</h5>
    <p>Look for forms, form fields and links that appear in the page source, but aren't visible on the page. The CSS style <code>display: none;</code> hides an element; remove the styling to make it visible again. Take a look at the HTML comments too!</p>

    <h4>System Fingerprinting Identify what components the system is using.</h4>
    <h5>Questions to ask</h5>
    <ul>
        <li>Which web server - Apache, nginx, IIS?</li>
        <li>Which web framework - .NET, Django, Struts?</li>
        <li>Which database - MSSQL, MySQL...?</li>
        <li>Version numbers for web server and other components - are they up to date?</li>
        <li>How do they handle session management? Did they use a framework or roll their own?</li>
    </ul>
    <h5>Where to look</h5>
    <ul>
        <li><strong>HTTP response headers</strong> - look for <code>Server</code> and <code>X-Powered-By</code></li>
        <li><strong>Error messages</strong> - look for version Info and stack traces.</li>
        <li><strong>Cookies</strong> - cookie names can reveal framework info. If they're managing cookies themselves, think about how they're being generated. Are they predictable? How are they processed on the server?</li>
    </ul>
    <h4>Open Source Intelligence (OSINT)Gather information on the public internet</h4>
    <h5>What to look for</h5>
    <ul>
        <li>Known vulnerabilities in frameworks/other components</li>
        <li>Default credentials</li>
        <li>Employee contact info/personal information</li>
    </ul>
    <h5>How to find it</h5>
    <ul>
        <li>Google error messages, cookie names, version headers, password hashes...</li>
        <li>Read framework/component documentation</li>
        <li>Read framework/component security advisories</li>
        <li>Look up company employees on social media</li>
    </ul>
    <blockquote>
        <p>Your Google searches aren't private! When testing real applications, don't Google password hashes or other highly sensitive information - not even in incognito mode.</p>
    </blockquote>

    <hr>

    <h3>Attacks</h3>
    <h4>Cross-Site Scripting (XSS) Inject malicious JavaScript into a webpage</h4>
    <p>XSS allows an attacker to inject client side code (HTML, JavaScript, etc.) into the page such that it is rendered in the victim's browser. XSS is possible when user input that hasn't been properly output-encoded is included in a web page. XSS can come in three types:</p>
    <ul>
        <li><strong>Reflected:</strong> script is provided by the caller, included in the response from the server, and executed in the browser. E.g. a search term provided in a URL parameter is rendered in the body of the page.</li>
        <li><strong>Persistent:</strong> script is stored in a datastore and included the body of the page when it is rendered. E.g. a forum that allows users to leave comments for one another.</li>
        <li><strong>DOM-based:</strong> script is included in the page via client-side JavaScript rendering. The malicious input is never sent to the server. E.g. an application that updates a user's display name client-side based on provided input. (example.com/welcome/#name=Bob)</li>
    </ul>

    <h5>What to Look For</h5>
    <p>Data or text you provided is reflected back to you on the page. If that data isn't properly encoded, an XSS vulnerability might be present.Examples:</p>
    <ul>
        <li>You search for "foo" in the site's search form. The results page says, "Your search for 'foo' returned no results""</li>
        <li>You navigate to example.com/fakePage. The 404 page says, "Sorry, page "fakePage" not found."</li>
        <li>You try to log in as user "bob" and the following error message is returned: "The user 'bob' does not exist."</li>
    </ul>

    <h5>Test Cases - Discovery</h5>
    <p>Once you find a place where your input is being reflected back to you, try one of these tests cases to see if it's being properly encoded.</p>
    <ul>
        <li><code>&lt;marquee&gt;</code> - if not properly encoded, causes content to scroll sideways across the page.</li>
        <li><code>&lt;plaintext&gt;</code> - if not properly encoded, causes browser to display raw HTML</li>
    </ul>

    <h5>Test Cases - Exploitation</h5>
    <p>To score points for XSS, your exploit must open up a JavaScript alert box.</p>
    <ul>
        <li><code>&lt;script&gt;alert(1)&lt;/script&gt;</code> - the simplest possible XSS exploit.</li>
        <li><code>&lt;img src="javascript:alert('xss')"/&gt;</code> - some applications filter <code>&lt;script&gt;</code> tags. This is one way to bypass that.</li>
        <li><code>&lt;body onload="alert('xss')"/&gt;"</code> - event handlers like <code>onload</code> are another XSS injection point.</li>
    </ul>
    <h4>SQL Injection Execute arbitrary SQL commands on the server. Possible when the server concatenates user-supplied data with SQL code.</h4>

    <h5>What to Look For</h5>
    <p>Look for places where the application could be querying a SQL database. If a page isn't completely static, it's probably retrieving information from a database. Think about what SQL code the application might be running. For example, when a user logs in, the SQL query might look like:</p>
    <pre>
        <code>SELECT \* FROM Users
        WHERE Username= '\[user input\]'
        AND password = '\[user input\]';</code>
    </pre>
    
    <h5>Special Characters</h5>
    <ul>
        <li><code>'</code> - a single quote delimits strings in SQL queries. Because most user input is wrapped in strings, this is usually your first step to breaking out of the string and changing the rest of the query.</li>
        <li><code>#</code>,<code>--</code> - comment signs. A comment sign tells the SQL interpreter to ignore the rest of the line.</li>
        <li><code>;</code> - a semicolon ends a SQL comment. This can be used to string multiple SQL commands together if the database supports it.</li>
        <li><code>OR</code>,<code>AND</code> - SQL supports boolean operators.</li>
        <li><code>&lt;</code>,<code>=</code> - SQL supports comparison operators. Note that comparison uses <code>=</code>, not <code>==</code>.</li>
    </ul>
    <h5>Test Cases</h5>
    <ul>
        <li><code>'</code> - a single quote is the simplest discovery test case. If that throws a SQL error, it's a sure sign you've found SQL injection.</li>
        <li><code>\'</code> - another discovery test case. Some databases escape special characters with backslashes. If the application escapes unsafe characters, this may bypass it.</li>
        <li><code>' OR 1=1#</code> - inserted into a <code>WHERE</code> clause, this forces it to evaluate to true. Good for bypassing authentication on login forms.</li>
    </ul>
    <h4>Forceful Browsing</h4>
    <p>Pages may just be hidden from users, not protected with proper access control checks. Forceful browsing may just mean browsing directly to an administrative page, or you might need to combine it with parameter tampering to view pages that you shouldn't have access to.</p>
    
    <h5>What to look for</h5>
    <p>Keep an eye on the URL. As an administrator or other privileged user, try browsing to as many authenticated pages as possible. Copy each URL to be used later.</p>
    <h5>Test Cases</h5>
    <p>Try to access each authenticated page (including any URL parameters) as an unauthenticated or lower-privileged user. If a page contains information that only one user should be able to access, log out, log in as another user, and try to browse to the page again.</p>
    <h4>Parameter Tampering</h4>
    <p>It's possible to change any form or URL parameter. Sometimes changing a value (like a user ID) can allow you to see or tamper with data without authorization.</p>
    <h5>What to look for</h5>
    <p>All parameters sent to the server:</p>
    <ul>
        <li>URL parameters</li>
        <li>Dropdowns</li>
        <li>Checkboxes</li>
        <li>Radio Buttons</li>
        <li>Hidden form fields</li>
        <li>Cookies</li>
    </ul>
    <h5>Test Cases</h5>
    <p>To tamper with a URL parameter, edit it in your address bar, then hit enter.
    To tamper with a form parameter, edit it using your browser's developer tools, then submit the form.</p>
    <h4>File Upload</h4>
    <p>There are lots of ways to abuse insecure file uploads. An attacker can upload code, then look for ways to execute it on the server. They can overwrite other files on the server. Or they could upload malicious scripts or malware that will execute when other users view them.</p>

    <h5>What to look for</h5>
    <p>Any file upload functionality.</p>

    <h5>Test Cases</h5>
    <p>Tamper with file names, paths, and extensions. Can you upload a file type that isn't permitted? Can you upload code and run it?</p>
    <hr>
    <h3>More Tools &amp; Resources</h3>
    <ul>
        <li><a href="http://pentestmonkey.net/cheat-sheet/sql-injection/mysql-sql-injection-cheat-sheet">SQL Injection Cheat Sheet</a></li>
        <li><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">OWASP XSS Filter Evasion Cheat Sheet</a></li>
        <li><a href="http://www.asciitohex.com/">ASCII to Hex</a> - General-purpose text encoding/decoding</li>
        <li><a href="https://crackstation.net/">CrackStation</a> - online password hash cracker</li>
        <li><a href="https://hashcat.net/hashcat/">hashcat</a> - offline password hash cracker</li>
    </ul>
</div>